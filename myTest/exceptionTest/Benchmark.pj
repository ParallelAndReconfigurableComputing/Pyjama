package exceptionTest;

import pj.*;
import java.io.PrintWriter;

public class Benchmark{
	public static void main (String[] args) {
		recordTime("pure_overhead_no_approach_100_0", 1000);
	}

	public static void recordTime(String fileName, int n) {
		PrintWriter writer = null;
		try {
			writer = new PrintWriter("/home/fxin927/benchmark/pure/" + fileName + ".txt", "UTF-8");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		for (int i=0; i<n; i++) {
			double value = test_no();
			writer.println(value);
		}
		writer.close();
	}

	public static double test_no() {
		long end = 0;
		long start = System.nanoTime();
			//#omp parallel 
			{

			}
		end = System.nanoTime()-start;
		return (double)(end)/1000000; //nanoseconds-> microseconds-> miliseconds
	}
	
	// souround parallel region with try-catch block
	public static double test_new() {
		long end = 0;
		long start = System.nanoTime();
		try {

			//#omp parallel
			{

			
			}

			
		} catch (RuntimeException e) {
			System.out.println("catch exception" + e);
		} 
		end = System.nanoTime()-start;
		return (double)(end)/1000000; //nanoseconds-> microseconds-> miliseconds
	}

//does not handle locally, stop entire parallel region, using conventional programming style
	public static double test_old() {
		RuntimeException re = new RuntimeException("null");
		RuntimeException reNull = re;
		long end = 0;
    	long start = System.nanoTime();

		//#omp parallel shared(re)
		{
			
		}

		if (re != reNull) {
			System.out.println("Handling thread outside parallel region " + re);
		}
		//System.out.println("finally");
		end = System.nanoTime()-start;
		return (double)(end)/1000000; //nanoseconds-> microseconds-> miliseconds
	}
}