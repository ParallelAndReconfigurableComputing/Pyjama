package PyjamaCode.TestingComplex;
import pj.*;

public class complex_positive_test1{
	public double[][] complex_test1(int threadNumber){
		Pyjama.omp_set_num_threads(threadNumber);
		int NI=32;
		int NJ=32;
		int NK=32;
		int NL=32;
		int alpha=32412;
		int beta=2123;
		double[][] a=new double[NI][NJ];
		double[][] b=new double[NI][NJ];
		double[][] c=new double[NI][NJ];
		double[][] d=new double[NI][NJ];
		double[][] tmp=new double[NI][NJ];
		//array initialization
		for (int i = 0; i < NI; i++)
			for (int j = 0; j < NK; j++)
            a[i][j] = ((double)i*j) / NI;
		for (int i = 0; i < NK; i++)
			for (int j = 0; j < NJ; j++)
				b[i][j] = ((double) i*(j+1)) / NJ;
		for (int i = 0; i < NL; i++)
			for (int j = 0; j < NJ; j++)
				c[i][j] = ((double) i*(j+3)) / NL;
		for (int i = 0; i < NI; i++)
			for (int j = 0; j < NL; j++)
				d[i][j] = ((double) i*(j+2)) / NK;
		//end
    
		long pre=System.currentTimeMillis();
		// pragma scop
		/* D := alpha*A*B*C + beta*D */
		//#omp parallel shared(NI,NJ,NK,a,b,tmp,alpha)
		{
		 //#omp for
		 for(int i = 0; i < NI; i++) {
	  	    for (int j = 0; j < NJ; j++){
		      tmp[i][j] = 0;
		         for (int k = 0; k < NK; ++k){
			     tmp[i][j] += alpha * a[i][k] * b[k][j];
		         }
	          }
           }
        }
		//#omp parallel shared(NI,NL,NJ,d,tmp,c,beta)
		{
			//#omp for
			for (int i = 0; i < NI; i++){
				for (int j = 0; j < NL; j++){
					d[i][j] *= beta;
					for (int k = 0; k < NJ; ++k){
						d[i][j] += tmp[i][k] * c[k][j];
					}
				}
			}
		}

		long pos=System.currentTimeMillis();
		long time=pos-pre;
		return d;
	}
}