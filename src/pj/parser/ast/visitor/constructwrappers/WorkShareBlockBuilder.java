package pj.parser.ast.visitor.constructwrappers;
/**
 * This is the representation for <code>parallel for</code>
 * construct.
 * 
 * It should be noted that this is an 
 * elementary directive. In scenarios, where
 * combined directives are used, they are again 
 * normalised into the elementary ones.
 * 
 * @author Xing Fan
 * @version 0.9
 */
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import pj.PjRuntime;
import pj.Pyjama;
import pj.parser.ast.body.VariableDeclaratorId;
import pj.parser.ast.expr.Expression;
import pj.parser.ast.expr.NameExpr;
import pj.parser.ast.omp.OmpForConstruct;
import pj.parser.ast.type.Type;
import pj.parser.ast.visitor.PyjamaToJavaVisitor;
import pj.parser.ast.visitor.SourcePrinter;



public class WorkShareBlockBuilder extends ConstructWrapper{
	
	private SourcePrinter printer;
	private PyjamaToJavaVisitor visitor;
	private OmpForConstruct ompForConstruct;
		
	public WorkShareBlockBuilder(OmpForConstruct forNode, PyjamaToJavaVisitor visitor) {	
		this.ompForConstruct = forNode;
		this.visitor = visitor;
		this.printer = new SourcePrinter();
	}
	
	public OmpForConstruct getForConstruct() {
		return this.ompForConstruct;
	}
	
	
	@Override
	public int getBeginLine() {
		return ompForConstruct.getBeginLine();
	}
	@Override
	public int getEndLine() {
		return ompForConstruct.getEndLine();
	}
	

	
	public String getSource()
	{
		this.generateMethod();
		return printer.getSource();
	}
	private void generateLoop() {
		ForStmtSimple forStmt = null;
		boolean iteratorDeclaration =false;
	    VariableDeclaratorId identifier = null;//the flag variable name in for statement
		Expression init_expression = null;//the starting number of the iterations
		Expression end_expression = null;//the ending number of the iterations
		String compareOperator = null;
		String stride = null;//the increment after each iteration
		if (this.ompForConstruct.getStatements().get(0) instanceof ForStmtSimple) {
			forStmt = (ForStmtSimple)this.forNode.getStatements().get(0);
			identifier = forStmt.getIdentifier();
			init_expression = forStmt.getInitExpression();
			end_expression = forStmt.getEndExpression();
			compareOperator = forStmt.getCompareOperator();
			stride = forStmt.getStride();
			if (null != forStmt.getInit()) {
				iteratorDeclaration = true;
			}
		}
		OpenMP_ScheduleClause schClause = this.forNode.getScheduleClause();
		OpenMP_ScheduleClause.Type schType = null;
		Expression chunkSize = null;
		if (null != schClause) {
			schType = schClause.getScheduleType();
			if (schClause.getChunkSize() != null) {
				chunkSize = schClause.getChunkSize();
			}
		}
		printer.printLn((iteratorDeclaration?"int ":"")+identifier+"=0;");
		
		printer.printLn("int OMP_iterator = 0;");
		printer.printLn("int OMP_end = (int)((" + end_expression + ")-(" + init_expression + "))/(" + stride + ");");
		if (compareOperator.equals("<") || compareOperator.equals(">")) {
			printer.printLn("if (((" + end_expression + ")-(" + init_expression + "))%(" + stride + ") == 0) {");
			printer.indent();
			printer.printLn("OMP_end = OMP_end - 1;");
			printer.unindent();
			printer.printLn("}");
		}
		/*
		 * Default scheduling type
		 */
		if(null == schClause){
			printer.printLn("int OMP_local_iterator = 0;");
			printer.printLn("int OMP_Chunk_Starting_point = 0;");
			printer.printLn("int OMP_Default_chunkSize_autoGenerated = (OMP_end+1)/Pyjama.omp_get_num_threads();");
			printer.printLn("if (Pyjama.omp_get_thread_num() < (OMP_end+1) % Pyjama.omp_get_num_threads()) {");
			printer.indent();
			printer.printLn("++OMP_Default_chunkSize_autoGenerated;");
			printer.printLn("OMP_Chunk_Starting_point = Pyjama.omp_get_thread_num() * OMP_Default_chunkSize_autoGenerated;");
			printer.unindent();
			printer.printLn("} else {");
			printer.indent();
			printer.printLn("OMP_Chunk_Starting_point = Pyjama.omp_get_thread_num() * OMP_Default_chunkSize_autoGenerated + (OMP_end+1) % Pyjama.omp_get_num_threads();");
			printer.unindent();
			printer.printLn("}");

			printer.printLn("for (OMP_local_iterator=OMP_Chunk_Starting_point; OMP_local_iterator<OMP_Chunk_Starting_point+OMP_Default_chunkSize_autoGenerated && OMP_Default_chunkSize_autoGenerated>0; ++OMP_local_iterator) {");
			printer.indent();
			printer.printLn(identifier+" = " + init_expression + " + OMP_local_iterator * (" + stride + ");");
			//BEGIN user code 
			this.ompForConstruct.getStatement().accept(visitor, printer);
			//END user code
			//BEGIN lastprivate value return
			printer.printLn("if (OMP_end == OMP_local_iterator) {");
			printer.indent();
			printer.printLn("//BEGIN lastprivate variables value set");
			DataClauseHandler.updateOutputlistForLastprivateVariables(this, printer);
			printer.printLn("//END lastprivate variables value set");
			printer.unindent();
			printer.printLn("}");
			//END lastprivate value return
			printer.unindent();
			printer.printLn("}");
		}	
		/*
		 * Static and default scheduling type
		 */
		if(pj.parser.ast.expr.OpenMP_ScheduleClause.Type.Static == schType){
			
			if (null == chunkSize) {
				chunkSize= new NameExpr(0,0,"1");
			}
			
			printer.printLn("int __omp_loop_thread_num = Pyjama.omp_get_thread_num();");
			printer.printLn("int __omp_loop_num_threads = Pyjama.omp_get_num_threads();");
			
			printer.printLn("for (OMP_iterator=__omp_loop_thread_num*"+chunkSize+"; OMP_iterator<="+"OMP_end && " + chunkSize +">0; OMP_iterator=OMP_iterator+__omp_loop_num_threads*"+chunkSize+") {");
			printer.indent();
			printer.printLn("for (int OMP_local_iterator = OMP_iterator; OMP_local_iterator<OMP_iterator+"+chunkSize+" && OMP_local_iterator<=OMP_end; "
							+"OMP_local_iterator++){");
			printer.indent();
			printer.printLn(identifier+" = " + init_expression + " + OMP_local_iterator * (" + stride + ");");
			//BEGIN user code 
			this.forNode.getStatements().get(0).accept(visitor, printer);
			//END user code
			//BEGIN lastprivate value return
			printer.printLn("if (OMP_end == OMP_local_iterator) {");
			printer.indent();
			printer.printLn("//BEGIN lastprivate variables value set");
			DataClauseHandler.updateOutputlistForLastprivateVariables(this, printer);
			printer.printLn("//END lastprivate variables value set");
			printer.unindent();
			printer.printLn("}");
			//END lastprivate value return
			printer.unindent();
			printer.printLn("}");
			printer.unindent();
			printer.printLn("}");
		}	
		
		/*
		 * dynamic scheduling type
		 */
		if(pj.parser.ast.expr.OpenMP_ScheduleClause.Type.Dynamic == schType){
			
			if (null == chunkSize) {
				chunkSize= new NameExpr(0,0,"1");
			}
			
			printer.printLn("if (0 == Pyjama.omp_get_thread_num()) {");
			printer.indent();
			printer.print("PjRuntime.get_OMP_loopCursor().getAndSet(0);");
			printer.unindent();
			printer.printLn("}");
			printer.printLn("PjRuntime.setBarrier();");

			printer.printLn("while ((OMP_iterator = PjRuntime.get_OMP_loopCursor().getAndAdd("+chunkSize+")) <= OMP_end) {");	
			printer.indent();
			printer.printLn("for (int OMP_local_iterator = OMP_iterator; OMP_local_iterator<OMP_iterator+"+chunkSize+" && OMP_local_iterator<=OMP_end; "
							+"OMP_local_iterator++){");
			printer.indent();
			printer.printLn(identifier+" = " + init_expression + " + OMP_local_iterator * (" + stride + ");");
			//BEGIN user code 
			this.forNode.getStatements().get(0).accept(visitor, printer);
			//END user code
			//BEGIN lastprivate value return
			printer.printLn("if (OMP_end == OMP_local_iterator) {");
			printer.indent();
			printer.printLn("//BEGIN lastprivate variables value set");
			DataClauseHandler.updateOutputlistForLastprivateVariables(this, printer);
			printer.printLn("//END lastprivate variables value set");
			printer.unindent();
			printer.printLn("}");
			//END lastprivate value return
			printer.printLn();
			printer.unindent();
			printer.printLn("}");
			///
			printer.unindent();
			printer.printLn("}");
			
		}	
		/*
		 * guided scheduling type
		 */
		if(pj.parser.ast.expr.OpenMP_ScheduleClause.Type.Guided == schType){
			
			if (null == chunkSize) {
				chunkSize= new NameExpr(0,0,"1");
			}
						
			printer.printLn("int OMP_chunkSize = " + chunkSize + ";");
			printer.print("if (0 == Pyjama.omp_get_thread_num()) {");
			printer.printLn("PjRuntime.get_OMP_loopCursor().getAndSet(0);}");
			printer.printLn("PjRuntime.setBarrier();");

			printer.printLn("while ((OMP_iterator = PjRuntime.get_OMP_loopCursor().getAndAdd(OMP_chunkSize)) <= OMP_end) {");	
			printer.indent();
			printer.printLn("for (int OMP_local_iterator = OMP_iterator; OMP_local_iterator<OMP_iterator+OMP_chunkSize && OMP_local_iterator<=OMP_end; "
							+"OMP_local_iterator++){");
			printer.indent();
			printer.printLn(identifier+" = " + init_expression + " + OMP_local_iterator * (" + stride + ");");
			//BEGIN user code 
			this.forNode.getStatements().get(0).accept(visitor, printer);
			//END user code
			//BEGIN lastprivate value return
			printer.printLn("if (OMP_end == OMP_local_iterator) {");
			printer.indent();
			printer.printLn("//BEGIN lastprivate variables value set");
			DataClauseHandler.updateOutputlistForLastprivateVariables(this, printer);
			printer.printLn("//END lastprivate variables value set");
			printer.unindent();
			printer.printLn("}");
			//END lastprivate value return
			printer.printLn();
			printer.unindent();
			printer.printLn("}");
			printer.printLn("if(OMP_chunkSize>1)OMP_chunkSize--;");
			///
			printer.unindent();
			printer.printLn("}");
			
		}	
	}
	private void generateMethod() {
		printer.printLn();
		printer.indent();printer.indent();printer.indent();printer.indent();
		//////////////////////////////////////////////
		printer.print("{");
		printer.indent();
		/////////////////BEGIN parallel worksharing code conversion///////////////////
		printer.printLn("//#BEGIN firstprivate lastprivate reduction variables defined and initialized here");
		DataClauseHandler.redeclareFirstprivateReductionLastPrivateVariablesForWorksharing(this, printer);
		printer.printLn("//#set implicit barrier here, otherwise unexpected initial value happens");
		printer.printLn("PjRuntime.setBarrier();");
		printer.printLn("//#END firstprivate lastprivate reduction variables defined and initialized here");
		
		// print the real for-loop code and enclosed user code
		generateLoop();
		printer.printLn("//BEGIN  reduction");
		printer.printLn("PjRuntime.reductionLockForWorksharing.lock();");
		DataClauseHandler.reductionForWorksharingBlock(this, printer);
		printer.print("PjRuntime.reductionLockForWorksharing.unlock();");
		printer.printLn("//END reduction");

		if (!this.forNode.isNoGui()) {
			printer.printLn("PjRuntime.setBarrier();");
		}
		printer.unindent();
		printer.printLn("}");
		
		/////////////////END parallel worksharing code conversion///////////////////

	}

	@Override
	public HashMap<String, Type> autoGetAllAvaliableSymbols() {
		// TODO Auto-generated method stub
		return null;
	}

}
